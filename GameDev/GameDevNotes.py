"""The notes are in python for use in an IDE, this allows easy collapsing to quickly get to critical sections or to hide
unnecessary information."""

The Game Loop 			-Lecture Notes 1-26-16
	Any game which has a real-time component will ahve a game loop, a repeated block of code which sends images to the display. 
	Even a turn-based game will typically have animation, requiring an animation loop.

	Typically we integrate into this loop input processing, timing, movement, and simulation, and rednering. 
	It's possible to split all of these.
	
	EXAMPLE OF BASIC GAME LOOP-
		while(playing){
			processInput();
			processObjects(elapsed_time);
			renderObjects();
		}
	Getting Input-
		Polling
			Some system require us to manually poll for new inputs; the input state will not be updated until we do so:
				While(playing){
					...
					pollInputs();
					//new input state
					if(mouseX > 100)
						...do stuff
				}
		State
				Some systems maintain the state of (some) input devices for us:
					while(playing){
						...
						if(mouseX > 100)
						...
					}
				The state is magically updates whenever input occurs. No events are lost, but there's no way to look up
				'historical' inputs.
		Event handlers
			Some systems (like proceessing) dispatch an event handler on input events.
			
			function mouseHandler(){
				if(mouseX > 100)
					//setflag
			}
			...
			while(playing){
			...
			if(mouseFlag)
				...
	Usually... 
		we prefer a state-based input representation. Most platforms do not provide this, 
		so we have to manually maintain it, either by polling frequently enough, or by updating a state object in the event handler.
	Generally we want to abstract over the input. ie:
		it(input.up)
			...
	instead of...
		if(keys[UP_ARROW])
			...
	Keyboard Input-
		A character?
			Mapping keys to character is handled by the OS or input library including combinations of keys.
		An event?
			Most systems trigger events on keyboard input: key pressed/key released
				Key pressed may be subject to OS generated key repeats, where a key that is held down generates a
				sequence of key-pressed events.
				
				A full key press, key released cycle is sometimes called a key click event.
				
				Jeyboards can only detect a limited number keys being held down, the so-called rollover. 
				Once n keys are depressed, no further events for other keys will be produced.
		A scan code?
			Codes generated by the keyboard itself, corresponding to individual keys(including modifier keys such as Shift, Control, Alt)
			They may not be normallized by the OS to account for layout.
		Other Devices
			Mice,gamepads,touchscreens, wierd spatial 3D things,etc.
			Analog devices(mice,component of gamepads) are modeled as collections of axes. A device will report how many axes it supports,
			along with their names, ranges, and resolutions.
			Except for the mouse wheel, its events are 'wheel up' and 'wheel down'
	Timing-
		Consistent accurate timing data is vital. We want our movement and animation to run at rates corresponding to the real world.
		(pixels per second, not pixels per frame)
		
		We need to know delta time, how long it takes to run an interation of the game loop. We'll use this in our physical simulation
		to advance the world state.
		
		Resolution-
			High-resolution timing is vital: simple frames may easily process and render in under a millisecond(and thus appear, when rounded down, to take no time at all!)
		
			Nanosecond timing is the minimum resolution that could be considered usable.
			
			In Java/Processing, System.nanoTime() will get you the number of nanoseconds since some.
			Undefined-but-consistent starting time. Similar functions exist in most animation libraries.
		Precision vs Accuracy-
			Precision refers to how many digits a number has.
			
			Accuracy refers to how many of these digits are actually right.
			
			It's not uncommon for timing data to have higher precision than accuracy. You may get a detailed value, 
			but the less-significant digits are likely just noise.
		Moving objects-
			The simplest way to move an object is to define its position as a function in terms of time t ie:
				o.x = t^2
				o.y = 2*t^3 - 4
			But this is completely inflexible and cannot respond to any inputs.
		Physical Movement
			To make an object that we can influence with physical forces(gravity, wind friction, collision, etc.)
			we need at least three things.
				Position - where is the object now?
				Velocity - what direction is the object moving, and how fast?
					The derivative of position.
				Acceleration - delta velocity
					The derivative of velocity
					
				Euler integration is the simplest numerical integration scheme.
		Euler integration
			For position, velocity, and accel Euler integration looks like this...
			p' = v*delta.t
			v' = a*delta.t
			a' = ...
			
			Delta t is the timestep, the amount of time elapsed since the last update.
			
			As a general rule, the smaller delta t, the more accurate our simulation will be.
			
			Euler integration, in particular is only 100% accurate if none of the values change during the delta t period.
			By making the delta t small, we can get very close.
		Timestep division
			If the timestep is too big to allow accurate simulation, we can subdivide the frame into subframes:
				repeat(10 times):
					prcoessObjects(elapsed_time / 10)
			Here we subdivide the processing step into 10 sub-steps,
			each with 1/10th the timestep.
		Aside: Friction
			Friction is a force whose direction is 180 degrees from velocity. But a force is an accelration.
			Which is the derivative of velocity. So effectively we have..
				v' = ... + - mu*v
			The derivative of v is defined in terms of v itself.
			This is a differential equationa nd solving it. 
		What is a random function?
			Suppose we define a function f such that f(x) is randomly drawn from the interval [-1,1] for any x
			
			This function is random noise:
		Random Walk
			Random noise is not very useful for movement as it simply jumps all ove rthe place.
			What happens if we integrate f?
			That is we want the function g such that..
			f(x) = dg/dx
			This is called a random walk.
	Rendering Ojects
		for(o in objects){
			o.draw()
		}
	Layers-
		Sometimes they must be drawn in a certain order to accomindate layering.
		Depth(3D) and Modes may require sorting.
	When we render...
		We'll cover this later on.
Graphics Overview		-Lecture Notes 2-2-16
	What is a display?
		A display is anything that gets our imagery to the user.
			Early displays were overglorified oscilloscopes, capable of displaying only vector imagery.
			CRT displays work by scanning an electron beam over phosphors, which glow(briefly) when powered.
		How much do we care about display technology?
			Only as much as is neeed to be aware of is flaws and limitations.
			Both CRTs and LCDs have a refresh cycle, where the image on the display is updated, row by row. (Leads to v-syncing, tearing, etc.)
			LCDs cannot display "true black", because some light always bleeds through.
			CLDs may have different subpixel layouts that can affect image bleeding and antialisaing.
		Displays vs Images
			We mostly care about iamges, less about displays. 
		What's an image?
			An image is a two-dimensional array containing representations of colors, so as to form a representation of two-dimensional visual signal.
		Colors vs color representations	
			A color is a mixture of various frequencies of elecrromagnetic radiation.
			A color representation is a data structure which attempts to capture the important characteristics of a color.
			The distinction is important because none of the color represntations we'll use are cpable of perfectrly capturing all visible colors.
		Additive color representations	
			Because our displays work by shining lights at the user, we usually
			prefer an additive color representation, one that tarts at black and adds in quanities of primary colors to form various hues.
			You will probably never use a display system that doesn't use an RGB color representation somewhere.
			The secondary colors yellow(RG), cyan(GB), and magenta(BR)
		RGB Colors	
			The range of real colors that can be represented by a particular representaiton and display is called its gamut.
		Gamma
			Gamut mostly doesn't matter to us. But another aspect of color reproduction does: gamma.
			Gamma is a non-linear adjustment applied to the luminosity of an image to allow for a larger dynamic range to be represented.
			A fixed-range color representaiton such a using 8 bit integers cannot represent an unlimited range. (floating point doesn't need adjustment.)
		What is an image?
			Formally, an image is a sample of a two-dimensional signal.
			Like an audio signal it is cature with some sample rate, its resolution.
			A pixel (a cell in the image's array) is thus not a little square but a sample point.
		Setting a pizel
			Relatively easy assuming row-major
				image[x+y*image.width] = color
		Filling rectangles
			Set all the pixels in the region to the desired color using a coupled of nested loops.
		Aside: Aliasing
			Theoretically, an iamge is a gample of a signal. As a sample, it has a fixed maximum to the frquencies it canc orrectly
			reconstruct.
			This is called the Nyquist frquency and it is half the sampling rate.
			Frequencies in the signal that are about the Nyquist frequency will be "folded" or aliased down to lower frequencies, creating spurious frequencies in the reconstructed signal.
		Graphic Terminology
			Bounding box - The rectangle that exactly encloses some shape.
			Clipping - Not drawing parts of a shape that fall outside the image. (or some smaller clipping region).
		Drawing Lines
			We cant to draw an (un-anti-aliased) line from a point x1,y1 to x2,y2 how do we do this?
			On blackboard
		Drawing Circles
			On blackboard
		Overlaying iamges("blitting")
			At integer coordinates, this is simply a matter of looping over the source image, copyin pixel colors into the
			desitnation iamge at the target locations.
			At non-integer coordinates, this is a kind of image transformation, which we'll talk about later.
		Introduction to transparency
			1-bit transparency: either fully transparent or fully opaque.
			When drawing, skip pixels with the transparency bit set.
			Alpha transparency: range of transparencyDrawn as the weighted average of the underlying pixels and the transparent pixels.
PLACEHOLDER