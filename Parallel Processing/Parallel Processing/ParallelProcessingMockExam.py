1. Write the Names of Three Different Approaches to Pipelining. Describe the difference...
	1. Scalar Pipeline: Traditional approach, goes in stages.
	2. Parallel Pipeline: Scalar Pipeline forks after some stages, additional paths for instructions to go down.
	3. Diversified Pipeline: Scalar Pipeline forks into specialized pipelines for different instruction types.
2. List Two Issues of Instruction Level Parallelism.
	1. Circuit Complexity (Increased Cost)
	2. Power Usage / Heat Generation
3. Write the Names of Two Different Approaches of Implementing Multiple Issue Processor. Explain the difference...
	1. A static approach, at compile time unrelated groups of instructions will be grouped up, and guesses will be made about why they're unreleated(test code to make these assertions and make corrective behavior), then different functional units can operate on these pieces of data at the same time. (VLIW)
	2. A dynamic approach where the processor makes these guesses and stores it's guesses in a buffer, if it is wrong it recorrects the behavior. (Superscalar)
4. List Two Issues of Multiple Issue Processors
	Same as ILP
5. How can threads be utilized to run instructions in parallel?(SMT)...
	By running multiple threads at the same time different threads in a single process can take advantage of multiple-issue, allowing it to perform actions across threads at the same time.
6. Explain the Two Types of Thread Level Parallelism. Explain the difference...
	Coarse-Grained: Processor switches between threads after each I/O.
	Fine-Grained: Processor switches between threads after each instruction.
7. Draw a Diagram of a SISD System...
	Von Neumann Model
8. Give Two Examples of SIMD Systems, explain how they work...
	1. Vector Processor
		Utilizes Array Based Registers and Operations with large amounts of ALUs.
		ALU have to be running or idle. Good at high level parallelism, terrible at anything more basic.
	2. GPU
		Runs input through pipeline, some of it programmable (scalar functions) and outputs pixel array.
9. Draw a diagram of the two major groups of MIMD Processors, list underneath all related systems from kai hwang's classification: SMP, PVP, MPP, DSM, COW
	Shared-Mem
		SMP, PVP
	Distr-Mem
		COW, DSM, MPP
10. Consider the problem of global sum computation with full tree reduction. Assume the problem size is n and there are k threads, which are a power of 2. Use can use my_rank to get the current processor.
	a. Create Psuedocode describing how to compute the first and last index computed by the array...
		if(my_rank < n%k)
			my_first= my_rank  * (n/k)+1
			my_last = my_first + (n/k)+1
		else
			my_first= my_rank  * (n/k)
			my_last = my_first + (n/k)+1
	b. Create Psuedocode describing how the data is sent/recieved based on the processor id...
		diff = 1
		divisor = 2
		while(diff <= p && !done)
			if my_rank % diff == 0
				partner = my_rank + core_diff
				sum += recieve(partner)
			else
				partner = my_rank - core_diff
				send(partner)
				done = true		
11. Explain the Different Between Data and Task Parallelism, what is the previous program an example of?...
	Data Parallelism: Partitioning Data to be Operated on separately.
	Task Parallelism: Partitioning Tasks to be Operated on separately.
12. List Three Issues of Creating Parallel Programs, Explain How to Solve Them...
	1. Syncrhonization: How to make a thread wait during critical sections.
	2. Messaging: How to have processes message eachother.
	3. Load Balancing: How to efficiently partition work across.
13. List the Three Parallel Programming Paradigms, Explain their Process...
	1. Explicit: ie: OpenMP, declares sections to be parallel.
	2. Implicit: Parallel to begin with, tends to be less efficient.
	3. Automatic: Convert automatically, terrible efficiency, sometimes impossible.
14. What is the Von Neumann Bottleneck? List Four Ways of Aleviating It and How They Work...
	The separation of slower Mem and faster CPU creates a bottleneck as CPU does work faster than MEM can be retrieved.
	1. Cache
		Store recently computed values, don't need to hit mem as often.
	2. Virtual Memory
		Caching for secondary storage, so Mem doesn't have to be even slower.
	3. ILP
		Doing actions in parallel reducing time idle.
	4. TLP
		When Mem is busy, can work on something else.
15. Draw the diagram of heiarchial design of multicore processor. List an Example System...
	Example: i7, Multiple integrated chips, each chip has multiple cores.
	Cores have their own cache, they have shared cache. Connected to Mem.
16. Consider Flynn's Taxonomy, where does the IBM/SONY Cell Processor belong to?...
	SIMD, MIMD
17. Draw a Diagram of Pipelined Design, Describe how it works...
	"Systolic Array": Data is passed along cores that each have their own tasks to do.
18. Draw a Diagram of Network-Based Design, Describe how it works...
	Multiple Computers connected by some IN.
19. Describe 5 Issues of Multicore Processore Design...
	1. Data Transfer Between Cores
	2. Scalable IN
	3. Lower Power
	4. Fault Tolerancy
	5. Efficient Mem and I/O Access
20. Describe the Purpose of Skillicorn's Taxonomy...
	To Further Discriminate between MIMD systems.
21. Describe the Difference Between Static and Dynamic Threads. State the Disadvantages of Each.
	Static: Make all at once, join all at once. Have to wait until done to make more.
	Dynamic Threads: Make threads as needed, behavior can be harder to predict. Can be out of order.
22. Write the Node Degree and Network Diameter for the following topologies...
	a. linear...
		2, n-1
	b. ring...
		2, n/2
	c. fully connected...
		n-1, 1
	d. K-D toiroidal mesh...
		2*K, K*Kth_root_of(n)/2
	e. binary-tree...
		3, 2(K-1)		
	f. K-D Hyper Cube...
		K,K
23. Explain the Difference between a 3-D Mesh and 3-D Hypercube
	Meshes scale up as as Grid, Many connections, Hypercubes have particular connections.
24. Describe Gray Coding...
	A scheme for labeling points of a IN
25. Consider a 4D Hypercube, assume the nodes are numbered 0000-1111 using gray coding. Show the following node sequences...
	a. 0010 to 1100 using left-link first...
		0010 xor 1100 = 1110 -> 0011
		0011 xor 1100 = ...
	b. 0010 to 1100 using right-link first...
		0010 xor 1100 = 1110 -> 1010
		1010 xor 1100 = ...
26. Consider a 2x2 X-Bar Switch, draw the following diagrams...
	a. Cross...
		...
	b. Upper-Broadcast...
		...
	c. Lower-Broadcast...
		...
	d. Pass...
		...
27. Draw a 8x8 Omega Network and Describe the Routing Mechanism...
	Highroad/low road approach described in 28.
28. Draw a 8x8 Benes Network and Describe the Routing Mechanism...
	...
	Go to all paths simultaniously until middle. Then follow highroad(0),lowroad(1) from any spot.
29. For a 16x16 Benes Network how many paths exist from the source to the destination?...
	16/2
30. For a 64x64 Omega Network how many 2x2 crossbar switches are needed?...
	log2(64)*64/2